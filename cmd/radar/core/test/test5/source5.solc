
contract ABC {
    enum IDTypes { CT00, CT01 }
    enum AccountTypes { RC00, RC01 }
    enum OrderStates { VALID, INVALID }
    enum DraftTypes { AC01, AC02 }
    enum TransferFlags { EM00, EM01 }
    enum ResponseTypes {  SU00, SU01 }
    enum ResultTypes {  SUCC, FAIL }
    enum OperationTypes {  SUCC, FAIL }
    enum OrderUpdatable { YES, NO }
    // code {
    // success  0
    // draft or account is not exist 1
    // no permission 2
    // you can't operate this draft 3
    // draft status is not satisfied 4
    // the order has been published  5
    // resp reject 6
    // name or bankNum error 7
    // the order cann't update because the draft has been accepted 8
    //}



    struct Account {
        bytes32 accountNumber;
        bytes32 name;
        bytes32 ID;
        IDTypes IDType;
        AccountTypes accountType;
        bytes32 businessBankNum;
        bytes32 businessBankName;
        bytes32 addr;
        bytes32 phoneNum;
        bytes32 modifyTime;
    }


    struct Order {
        bytes32 orderNum;
        int amount;
        bytes32 buyerAccountNum;
        bytes32 buyerAccountName;
        bytes32 buyerBankNum;
        bytes32 sellerAccountNum;
        bytes32 sellerAccountName;
        bytes32 sellerBankNum;
        bytes32 orderConfirmTime;
        bytes32 orderDueTime;
        OrderStates OrderState;
        int draftAmount;//订单所有票据的面额总和
        OrderUpdatable updatable;

    }

    struct Draft {
        bytes32 draftNum;
        DraftTypes draftTypes;
        int amount;
        uint256 issueDraftApplyDate;
        uint256 dueDate;
        bytes32 drawerId;
        bytes32 acceptorId;
        bytes32 payeeId;
        bytes32 bearerId;
        string note;
        bytes32 orderNum;
        bool autoReceiveDraft;
        bytes32 draftStatus;
        bytes32 lastStatus;
        bytes32 firstOwner;
        bytes32 secondOwner;
        bytes32 discountRate;
    }

    struct DraftRecord {
        bytes32 draftNum;
        bytes32 busiType;
        bytes32 responseType;
        bytes32 mark;
        bytes32 applicantNum;
        bytes32 replyerNum;
    }




    //key-> accountNumber ,value-> Account
    mapping(bytes32 => Account) accounts; //保存所有的电商平台帐户

    //key->accountNumber, value-> Account[]
    mapping(bytes32 => Account[]) accModiHistory; //保存电商平台帐户修改历史

    //accountNumber
    bytes32[] accountArray;  //用于数据迁移


    //ordernumber
    mapping(bytes32 => Order) orders;

    //Key->accountNum, value-> draftNum[]
    mapping(bytes32 => bytes32[]) accountOrderNums;

    //orderNum
    bytes32[] ordersArray;


    //key->draftNum, value ->draft
    mapping(bytes32 => Draft) drafts;  //存所有的票据

    //key->secondOwner, value ->draft
    mapping(bytes32 => bytes32[]) unSignDrafts;  //下手持票人所持有的待处理票据

    //key->firstOwner, value ->draftNums
    mapping(bytes32 => bytes32[]) holdDrafts;  //本手持票人所持有的票据

    //key ->draft num, value->draftRecond[]
    mapping(bytes32=>DraftRecord[]) allDraftRecords; //每张票据的所有状态记录


    bytes32[] draftsArray;


    //key-> order num, value ->drafts num
    mapping(bytes32 => bytes32[]) orderDraftNums;

    bytes32 state;


    //==============================================================================================================

    function ABC(bytes32 input)  {
       state = input;
    }



    //================================================================================================================
    //此区域是放置全部变量的get,set方法，按命名规则来进行命名

    //todo ,考虑分页



    function getaccountArrayList(uint startindex,uint endindex) returns(bytes32[] accountsOutput,uint256 size) {
        accountsOutput = getSubArray(accountArray,startindex,endindex);
        return (accountsOutput,accountArray.length);
    }


    function setaccountArrayList(bytes32[] accountsInput) returns(bytes32 code) {
        for(uint i=0; i<accountsInput.length; i++) {
            accountArray.push(accountsInput[i]);
        }
        return (0);
    }


    function getSizeRefaccModiHistory(bytes32 accountNumber) returns(uint size) {
        Account[] memory accountArray =  accModiHistory[accountNumber];
        return accountArray.length;
    }




    function getaccountsMapRefaccountArray(bytes32 accountNumber)
    returns(bytes32 accountNum,bytes32 name,bytes32 id,IDTypes idtypes,AccountTypes accountTypes,
    bytes32 businessBankNum,bytes32 businessBankName,bytes32 addr,bytes32 phoneNum,bytes32 modifyTime) {
        Account memory account = accounts[accountNumber];
        return(account.accountNumber,
               account.name,
               account.ID,
               account.IDType,
               account.accountType,
               account.businessBankNum,
               account.businessBankName,
               account.addr,
               account.phoneNum,
               account.modifyTime);
    }

    function setaccountsMapRefaccountArray(bytes32 accountNum,bytes32 name,bytes32 id,IDTypes idtypes,AccountTypes accountTypes,
    bytes32 businessBankNum,bytes32 businessBankName,bytes32 addr,bytes32 phoneNum,bytes32 modifyTime) returns(bytes32 code) {
        Account account = accounts[accountNum];
        if(account.accountNumber!=0x0) {
            return (1);
        }
        account.accountNumber = accountNum;
        account.name = name;
        account.ID = id;
        account.IDType = idtypes;
        account.accountType = accountTypes;
        account.businessBankNum = businessBankNum;
        account.businessBankName = businessBankName;
        account.addr = addr;
        account.phoneNum = phoneNum;
        account.modifyTime = modifyTime;
        return (0);
    }


    function getaccModiHistoryMapRefaccountArray(bytes32 accountNumber,uint index)
    returns(bytes32 accountNum,bytes32 name,bytes32 id,IDTypes idtypes,AccountTypes accountTypes,
    bytes32 businessBankNum,bytes32 businessBankName,bytes32 addr,bytes32 phoneNum,bytes32 modifyTime) {
        Account[] memory accountArray =  accModiHistory[accountNumber];
        if(accountArray.length==0||accountArray.length<=index) {
            return (0x0,0x0,0x0,IDTypes.CT00,AccountTypes.RC00,0x0,0x0,0x0,0x0,0x0);
        }

        Account memory account = accountArray[index];
        return(account.accountNumber,
               account.name,
               account.ID,
               account.IDType,
               account.accountType,
               account.businessBankNum,
               account.businessBankName,
               account.addr,
               account.phoneNum,
               account.modifyTime);
    }



    function setaccModiHistoryMapRefaccountArray(bytes32 accountNumber,bytes32 name,bytes32 id,IDTypes idtypes,AccountTypes accountTypes,
    bytes32 businessBankNum,bytes32 businessBankName,bytes32 addr,bytes32 phoneNum,bytes32 modifyTime) returns(bytes32 code) {
        Account memory account;
        account.accountNumber = accountNumber;
        account.name = name;
        account.ID = id;
        account.IDType = idtypes;
        account.accountType = accountTypes;
        account.businessBankNum = businessBankNum;
        account.businessBankName = businessBankName;
        account.addr = addr;
        account.phoneNum = phoneNum;
        account.modifyTime = modifyTime;
        accModiHistory[accountNumber].push(account);
        return (0);
    }


    //order模块
    function getordersArrayList(uint startindex,uint endindex) returns(bytes32[] ordersOutput,uint size) {
        ordersOutput = getSubArray(ordersArray,startindex,endindex);
        return (ordersOutput,ordersArray.length);
    }

    function setordersArrayList(bytes32[] ordersInput) returns(bytes32 code) {
        for(uint i=0;i < ordersInput.length; i++) {
            ordersArray.push(ordersInput[i]);
        }
        return (0);
    }


    function getordersMapPart1RefordersArray(bytes32 orderNum) returns(bytes32 orderNumber,int256 amount,bytes32 buyerAccountNum, bytes32 buyerAccountName, bytes32 buyerBankNum,
    bytes32 sellerAccountNum, bytes32 sellerAccountName, bytes32 sellerBankNum) {
        Order order = orders[orderNum];
        if(order.orderNum==0x0){
            return (orderNumber,
                    amount,
                    buyerAccountNum,
                    buyerAccountName,
                    buyerBankNum,
                    sellerAccountNum,
                    sellerAccountName,
                    sellerBankNum);
        }
        return (order.orderNum,
                order.amount,
                order.buyerAccountNum,
                order.buyerAccountName,
                order.buyerBankNum,
                order.sellerAccountNum,
                order.sellerAccountName,
                order.sellerBankNum);
    }


    function getordersMapPart2RefordersArray(bytes32 orderNum) returns(bytes32 orderConfirmTime, bytes32 orderDueTime,
    OrderStates OrderState,int256 draftAmount,OrderUpdatable updatable) {
        Order order = orders[orderNum];
        if(order.orderNum == 0x0) {
            return (orderConfirmTime,
                    orderDueTime,
                    OrderState,
                    draftAmount,
                    updatable);
        }
        return (order.orderConfirmTime,
                order.orderDueTime,
                order.OrderState,
                order.draftAmount,
                order.updatable);
    }


    function setordersMapPart1RefordersArray(bytes32 orderNumber,int256 amount,bytes32 buyerAccountNum, bytes32 buyerAccountName, bytes32 buyerBankNum,
    bytes32 sellerAccountNum, bytes32 sellerAccountName, bytes32 sellerBankNum) returns(bytes32 code) {
        Order order = orders[orderNumber];
        if(order.orderNum != 0x0) {
            return (1);
        }
        order.orderNum = orderNumber;
        order.amount = amount;
        order.buyerAccountNum = buyerAccountNum;
        order.buyerAccountName = buyerAccountName;
        order.buyerBankNum = buyerBankNum;
        order.sellerAccountNum = sellerAccountNum;
        order.sellerAccountName = sellerAccountName;
        order.sellerBankNum = sellerBankNum;
        return (0);
    }

    function setordersMapPart2RefordersArray(bytes32 orderNumber,bytes32 orderConfirmTime, bytes32 orderDueTime,
    OrderStates OrderState,int256 draftAmount,OrderUpdatable updatable) returns(bytes32 code) {
        Order order = orders[orderNumber];
        if(order.orderConfirmTime != 0x0){
            return (1);
        }
        order.orderConfirmTime = orderConfirmTime;
        order.orderDueTime = orderDueTime;
        order.OrderState = OrderState;
        order.draftAmount = draftAmount;
        order.updatable = updatable;
        return (0);
    }




    //todo 考虑分页

    // function getSizeRefaccountOrderNums(bytes32 accountNumber) returns(uint size) {
    //     return accountOrderNums[accountNumber].length;
    // }

    function getaccountOrderNumsListMapRefordersAndaccountArray(bytes32 accountNumber,uint startindex,uint endindex) returns(bytes32[] accountOrdersOutput,uint size)  {
        accountOrdersOutput = getSubArray(accountOrderNums[accountNumber],startindex,endindex);
        return (accountOrdersOutput,accountOrderNums[accountNumber].length);
    }

    function setaccountOrderNumsListMapRefordersAndaccountArray(bytes32 accountNumber,bytes32[] accountOrdersInput) returns(bytes32 code) {
        for(uint i=0; i< accountOrdersInput.length; i++) {
            accountOrderNums[accountNumber].push(accountOrdersInput[i]);
        }
        return (0);
    }




    //draft 模块


    function getdraftsArrayList(uint startindex,uint endindex) returns(bytes32[] draftsArrayOutput,uint size) {
        draftsArrayOutput = getSubArray(draftsArray,startindex,endindex);
        return (draftsArrayOutput,draftsArray.length);
    }

    function setdraftsArrayList(bytes32[] draftsArrayInput) returns(bytes32 code) {
        for(uint i=0; i< draftsArrayInput.length; i++) {
            draftsArray.push(draftsArrayInput[i]);
        }

        return (0);
    }



    function getdraftsMapPart1RefdraftsArray(bytes32 draftNumber)
    returns (bytes32 draftNum,DraftTypes draftTypes,int amount,uint256 issueDraftApplyDate,
    uint256 dueDate,bytes32 drawerId,bytes32 acceptorId,bytes32 payeeId,bytes32 bearerId) {
        Draft memory draft = drafts[draftNumber];
        if(draft.draftNum == 0x0) {
            return (draftNum,
                    draftTypes,
                    amount,
                    issueDraftApplyDate,
                    dueDate,
                    drawerId,
                    acceptorId,
                    payeeId,
                    bearerId);
        }

        return (draft.draftNum,
                draft.draftTypes,
                draft.amount,
                draft.issueDraftApplyDate,
                draft.dueDate,
                draft.drawerId,
                draft.acceptorId,
                draft.payeeId,
                draft.bearerId);
    }



    function getdraftsMapPart2RefdraftsArray(bytes32 draftNumber)
    returns(string note,bytes32 orderNum,bool autoReceiveDraft,bytes32 draftStatus,
    bytes32 lastStatus,bytes32 firstOwner,bytes32 secondOwner,bytes32 discountRate) {
        Draft memory draft = drafts[draftNumber];
        if(draft.draftNum == 0x0) {
            return (note,
                    orderNum,
                    autoReceiveDraft,
                    draftStatus,
                    lastStatus,
                    firstOwner,
                    secondOwner,
                    discountRate);
        }

        return (draft.note,
                draft.orderNum,
                draft.autoReceiveDraft,
                draft.draftStatus,
                draft.lastStatus,
                draft.firstOwner,
                draft.secondOwner,
                draft.discountRate);
    }


    function setdraftsMapPart1RefdraftsArray(bytes32 draftNum,DraftTypes draftTypes,int amount,uint256 issueDraftApplyDate,
    uint256 dueDate,bytes32 drawerId,bytes32 acceptorId,bytes32 payeeId,bytes32 bearerId) returns (bytes32 code) {
        Draft memory draft = drafts[draftNum];
        if(draft.draftNum != 0x0) {
            return (1);
        }

        draft.draftNum = draftNum;
        draft.draftTypes = draftTypes;
        draft.amount = amount;
        draft.issueDraftApplyDate = issueDraftApplyDate;
        draft.dueDate = dueDate;
        draft.drawerId = drawerId;
        draft.acceptorId = acceptorId;
        draft.payeeId = payeeId;
        draft.bearerId = bearerId;
        return (0);
    }

    function setdraftsMapPart2RefdraftsArray(bytes32 draftNum,string note,bytes32 orderNum,bool autoReceiveDraft,bytes32 draftStatus,
    bytes32 lastStatus,bytes32 firstOwner,bytes32 secondOwner,bytes32 discountRate) returns (bytes32 code) {
        Draft memory draft = drafts[draftNum];
        if(draft.orderNum != 0x0) {
            return (1);
        }

        draft.note = note;
        draft.orderNum = orderNum;
        draft.autoReceiveDraft = autoReceiveDraft;
        draft.draftStatus = draftStatus;
        draft.lastStatus = lastStatus;
        draft.firstOwner = firstOwner;
        draft.secondOwner = secondOwner;
        draft.discountRate = discountRate;
        return (0);
    }




    function getunSignDraftsListMapRefdraftsAndaccountArray(bytes32 secondOwner,uint startindex,uint endindex) returns(bytes32[] unsignDraftsOutput,uint size) {
        unsignDraftsOutput = getSubArray(unSignDrafts[secondOwner],startindex,endindex);
        return (unsignDraftsOutput,unSignDrafts[secondOwner].length);
    }

    function setunSignDraftsListMapRefdraftsAndaccountArray(bytes32 secondOwner,bytes32[] unsindraftsInput) returns(bytes32 code) {
        for(uint i=0; i < unsindraftsInput.length;i++) {
            unSignDrafts[secondOwner].push(unsindraftsInput[i]);
        }
        return (0);
    }


    function getholdDraftsListMapRefdraftsAndaccountArray(bytes32 firstOwner,uint startindex,uint endindex) returns(bytes32[] holdDraftsOutput,uint size) {
        holdDraftsOutput = getSubArray(holdDrafts[firstOwner],startindex,endindex);
        return (holdDraftsOutput,holdDrafts[firstOwner].length);
    }

    function setholdDraftsListMapRefdraftsAndaccountArray(bytes32 firstOwner,bytes32[] holddraftsInput) returns(bytes32 code) {
        for(uint i=0; i < holddraftsInput.length; i++) {
            holdDrafts[firstOwner].push(holddraftsInput[i]);
        }

        return (0);
    }


    function getSizeRefallDraftRecords(bytes32 draftNum) returns(uint size) {
        return allDraftRecords[draftNum].length ;
    }

    function getallDraftRecordsMapRefdraftsArray(bytes32 draftNumber,uint index)
    returns(bytes32 draftNum,bytes32 busiType,bytes32 responseType,
        bytes32 mark,bytes32 applicantNum,bytes32 replyerNum) {

        DraftRecord[] memory draftrecords = allDraftRecords[draftNumber];

        if( draftrecords.length <= index ) {
            return (draftNum,
                    busiType,
                    responseType,
                    mark,
                    applicantNum,
                    replyerNum);
        }

        return (draftrecords[index].draftNum,
                draftrecords[index].busiType,
                draftrecords[index].responseType,
                draftrecords[index].mark,
                draftrecords[index].applicantNum,
                draftrecords[index].replyerNum);
    }


    function setallDraftRecordsMapRefdraftsArray(bytes32 draftNum,bytes32 busiType,bytes32 responseType,
        bytes32 mark,bytes32 applicantNum,bytes32 replyerNum) returns(bytes32 code) {
        DraftRecord memory draftrecord ;
        draftrecord.draftNum  = draftNum;
        draftrecord.busiType = busiType;
        draftrecord.responseType = responseType;
        draftrecord.mark = mark;
        draftrecord.applicantNum = applicantNum;
        draftrecord.replyerNum = replyerNum;

        allDraftRecords[draftNum].push(draftrecord);
        return (0);

    }



    function getorderDraftNumsListMapRefdraftsAndordersArray(bytes32 orderNum,uint startindex,uint endindex) returns(bytes32[] orderdraftsOutput,uint size) {
        orderdraftsOutput = getSubArray(orderDraftNums[orderNum],startindex,endindex);
        return ( orderdraftsOutput,orderDraftNums[orderNum].length);
    }

    function setorderDraftNumsListMapRefdraftsAndordersArray(bytes32 orderNum, bytes32[] orderdraftsInput) returns(bytes32 code) {
        for(uint i=0; i < orderdraftsInput.length; i++) {
            orderDraftNums[orderNum].push(orderdraftsInput[i]);
        }
        return (0);
    }

    //================================================================================================================




    //########
    //新建账户
    function newAccount(bytes32 accountNumber, bytes32 name, bytes32 ID,
    IDTypes IDType, AccountTypes accountType, bytes32 businessBankNum,
    bytes32 businessBankName, bytes32 addr, bytes32 phoneNum) returns(bool, bytes32, bytes32) {
        if (accounts[accountNumber].name != 0x0) {
            return (false, "1", "The account has been created");
        }
        Account account = accounts[accountNumber];
        account.accountNumber = accountNumber;
        account.name = name;
        account.ID = ID;
        account.IDType = IDType;
        account.accountType = accountType;
        account.businessBankNum = businessBankNum;
        account.businessBankName = businessBankName;
        account.addr = addr;
        account.phoneNum = phoneNum;
        accountArray.push(accountNumber);
        return (true, "0", "success");
    }

    //########
    //账户信息更新
    function updateAccountInfo(bytes32 accountNumber, bytes32 name, bytes32 ID,
    IDTypes IDType, AccountTypes accountType, bytes32 businessBankNum,
    bytes32 businessBankName, bytes32 addr, bytes32 phoneNum, bytes32 modifyTime)returns(bool, bytes32, bytes32) {
        Account account = accounts[accountNumber];
        if(account.name == 0x0) {
            return (false, "1", "The account is not exist");
        }
        account.name = name;
        account.ID = ID;
        account.IDType = IDType;
        account.accountType = accountType;
        account.businessBankNum = businessBankNum;
        account.businessBankName = businessBankName;
        account.addr = addr;
        account.phoneNum = phoneNum;
        account.modifyTime = modifyTime;
        accModiHistory[accountNumber].push(account);
        return (true, "0", "success");
    }

    //########
    //删除账户
    function deleteAccount(bytes32 accountNumber) returns(bool, bytes32, bytes32) {
        accounts[accountNumber].accountNumber = 0x0;
        accounts[accountNumber].name = 0x0;
        accounts[accountNumber].ID = 0x0;
        accounts[accountNumber].businessBankNum = 0x0;
        accounts[accountNumber].businessBankName = 0x0;
        accounts[accountNumber].addr = 0x0;
        accounts[accountNumber].phoneNum = 0x0;
        deleteArrayElement(accountArray,accountNumber);
        return (true, "0", "success delete");
    }



    //########
    //订单发布
    function pubOrderInfo(bytes32 orderNum, int amount, bytes32 buyerAccountNum,
      bytes32 buyerAccountName, bytes32 buyerBankNum, bytes32 sellerAccountNum,
      bytes32 sellerAccountName, bytes32 sellerBankNum, bytes32 orderConfirmTime,
      bytes32 orderDueTime) returns(bool, bytes32, bytes32) {
        Order order = orders[orderNum];
        if (order.orderNum != 0x0) {
            return (false, "5", "the order has been published");
        }
        if (accounts[buyerAccountNum].name == 0x0 || accounts[sellerAccountNum].name == 0x0) {
            return (false, "2", "account is not exist");
        }
        setOrder(orderNum,amount,buyerAccountNum,buyerAccountName,buyerBankNum,sellerAccountNum,sellerAccountName,
        sellerBankNum,orderConfirmTime,orderDueTime,OrderStates.VALID);
         //order.OrderState = OrderStates.VALID;
        setAccountOrders(orderNum, buyerAccountNum, sellerAccountNum);
        return (true, "0", "publish order success");
    }


    function setOrder(bytes32 orderNum, int amount, bytes32 buyerAccountNum,
      bytes32 buyerAccountName, bytes32 buyerBankNum, bytes32 sellerAccountNum,
      bytes32 sellerAccountName, bytes32 sellerBankNum, bytes32 orderConfirmTime,
      bytes32 orderDueTime,OrderStates orderStates) internal returns(bool){
        Order order = orders[orderNum];
        order.orderNum = orderNum;
        order.amount = amount;
        order.buyerAccountNum = buyerAccountNum;
        order.buyerAccountName = buyerAccountName;
        order.buyerBankNum = buyerBankNum;
        order.sellerAccountNum = sellerAccountNum;
        order.sellerAccountName = sellerAccountName;
        order.sellerBankNum = sellerBankNum;
        order.orderConfirmTime = orderConfirmTime;
        order.orderDueTime = orderDueTime;
        order.OrderState = OrderStates.VALID;
        ordersArray.push(orderNum);
        return true;
    }


    function setAccountOrders(bytes32 orderNum, bytes32 buyerAccountNum, bytes32 sellerAccountNum) internal {
        accountOrderNums[buyerAccountNum].push(orderNum);
        accountOrderNums[sellerAccountNum].push(orderNum);
    }


    //########
    //出票申请
    function issueDraftApply(bytes32 draftNum, DraftTypes draftType, int amount, uint256 applyDate, uint256 dueDate,
    bytes32 drawerId, bytes32 acceptorId, bytes32 payeeId, string notes, bytes32 orderNum, bool isAuto)returns(bool, bytes32, bytes32) {
        Order order = orders[orderNum];
        if (order.orderNum == 0x0) {
            return (false, "5", "the order has not been published");
        }
        //order所有票据总价不高于订单价格
        if(order.amount  <  amount + order.draftAmount) {
            return (false, "2", "order amount error");
        }
        if(!judgeDrawer(drawerId)) {
            return (false, "3", "drawer account error");
        }
        //acceptor
        if(judgeAcceptor(acceptorId, draftType)) {
            if(judgePayee(payeeId)) {
                setDraft(draftNum, draftType, amount, applyDate, dueDate, drawerId, acceptorId, payeeId, notes, orderNum, isAuto);
                addDraftRecord(draftNum, "P38", "SU00", "issueDraft", drawerId, acceptorId);
                if(draftType == DraftTypes.AC02) {
                    if(drawerId == acceptorId) {//承兑人等于出票人，自动默认承兑成功
                        //todo
                        setDraftStatus(draftNum, "020006");//状态变为承兑已签收
                        addDraftRecord(draftNum, "P38", "SU00", "issueDraft", drawerId, drawerId);
                        return acceptByAccount(draftNum, ResponseTypes.SU00, acceptorId, accounts[acceptorId].name, accounts[acceptorId].businessBankNum);
                    }
                }
                return (true,"0","draft apply success");
            }else {
                return (false, "4", "payee account  error");
            }
        }else {
            return (false, "5", "acceptor account type error");
        }
    }


    function setDraft(bytes32 draftNum, DraftTypes draftType, int amount, uint256 applyDate, uint256 dueDate,
        bytes32 drawerId, bytes32 acceptorId, bytes32 payeeId, string notes, bytes32 orderNum, bool isAuto) internal returns (bool) {

        newDraftUser(draftNum, drawerId, acceptorId, payeeId, drawerId, orderNum, isAuto, notes);
        newDraftBase(draftNum, "020001", draftType);
        Draft draft = drafts[draftNum];
        draft.dueDate = dueDate;
        draft.amount = amount;
        draft.lastStatus = "020001";
        draft.issueDraftApplyDate = applyDate;
        orderDraftNums[orderNum].push(draftNum);
        addOrderDraftAmount(draft.orderNum, draft.amount);
        draftsArray.push(draftNum);
        return true;
    }

    function newDraftBase(bytes32 draftNum, bytes32 draftStatus, DraftTypes draftType) internal {
        drafts[draftNum].draftNum = draftNum;
        drafts[draftNum].draftTypes = draftType;
        drafts[draftNum].draftStatus = draftStatus;
    }

    function newDraftUser(bytes32 draftNum, bytes32 drawerId, bytes32 acceptorId,
        bytes32 payeeId, bytes32 bearerId, bytes32 orderNum, bool isAuto, string notes) internal {

        Draft draft = drafts[draftNum];
        draft.drawerId = drawerId;
        draft.acceptorId = acceptorId;
        draft.payeeId = payeeId;
        draft.bearerId = bearerId;
        draft.note = notes;
        draft.orderNum = orderNum;
        draft.firstOwner = drawerId;
        draft.autoReceiveDraft = isAuto;
    }

    function setDraftStatus(bytes32 draftNum, bytes32 status) internal {
        drafts[draftNum].draftStatus = status;
    }

    function addOrderDraftAmount(bytes32 orderNum, int amount) internal {
        Order order = orders[orderNum];
        order.draftAmount = order.draftAmount + amount;
    }




    //########
    //商承承兑
    // function acceptByAccount(bytes32 draftNum, ResponseTypes responseType, bytes32 replyerNum, bytes32 replyerName, bytes32 replyerBankNum) returns(bool, bytes32, bytes32) {
    //     if(!judgeAccountCorrect(replyerNum, replyerName, replyerBankNum)) {
    //         return (false, "7", "name or bankNum error");
    //     }
    //     Draft draft = drafts[draftNum];
    //     if(draft.draftNum == 0x0) {
    //         return (false, "1", "draft is not exist");
    //     }
    //     if(draft.draftTypes == DraftTypes.AC01) {
    //         return (false, "2", "no permission");
    //     }
    //     if(ResponseTypes.SU01 == responseType) {
    //         draft.draftStatus = "000002";
    //         resetOrderDraftAmount(draft.orderNum, draft.amount);//票据作废，重置订单票据面额
    //     }else if(ResponseTypes.SU00 == responseType) {
    //         addDraftRecord(draftNum, "P54", "SU01", "receive issue draft apply", 0x0, replyerNum);
    //         draft.lastStatus = draft.draftStatus;
    //         draft.draftStatus = "020006";
    //         setOrderNonupdatable(draft.orderNum);//承兑完成，订单信息不可再更新
    //         if(draft.autoReceiveDraft) {
    //             //todo
    //             bytes32 msg;
    //             bytes32 codeStatus;
    //             bool result;
    //             (result, codeStatus, msg)  = receiveDraftApply(draftNum, draft.drawerId, accounts[draft.drawerId].name, accounts[draft.drawerId].businessBankNum);
    //             if(!result) {
    //                 return (false, codeStatus, msg);
    //             }
    //         }
    //     }
    //     return (true, "0", "accept success");
    // }


    function acceptByAccount(bytes32 draftNum, ResponseTypes responseType, bytes32 replyerNum, bytes32 replyerName, bytes32 replyerBankNum) returns(bool, bytes32, bytes32) {
        if(!judgeAccountCorrect(replyerNum, replyerName, replyerBankNum)) {
            return (false, "7", "name or bankNum error");
        }
        Draft draft = drafts[draftNum];
        if(draft.draftNum == 0x0) {
            return (false, "1", "draft is not exist");
        }
        if(draft.draftStatus!="020001"){
              return(false, "4", "draft status is not satisfied");
          }
        if(draft.draftTypes == DraftTypes.AC01) {
            return (false, "2", "no permission");
        }
        if(ResponseTypes.SU01 == responseType) {
            addDraftRecord(draftNum, "P54", "SU01", "reject issue draft apply", 0x0, replyerNum);
            draft.draftStatus = "000002";
            resetOrderDraftAmount(draft.orderNum, draft.amount);//票据作废，重置订单票据面额
            return (true, "6", "resp reject");
        }else if(ResponseTypes.SU00 == responseType) {
            addDraftRecord(draftNum, "P54", "SU01", "receive issue draft apply", 0x0, replyerNum);
            draft.lastStatus = draft.draftStatus;
            draft.draftStatus = "020006";
            unSignDrafts[draft.drawerId].push(draftNum);
            setOrderNonupdatable(draft.orderNum);//承兑完成，订单信息不可再更新
            if(draft.autoReceiveDraft) {
                //todo
                bytes32 msg;
                bytes32 codeStatus;
                bool result;
                (result, codeStatus, msg)  = receiveDraftApply(draftNum, draft.drawerId, accounts[draft.drawerId].name, accounts[draft.drawerId].businessBankNum);
                if(!result) {
                    return (false, codeStatus, msg);
                }
            }
        }
        return (true, "0", "accept success");
    }



    //出票申请被拒绝，重置订单票据面额
    function resetOrderDraftAmount(bytes32 orderNum, int amount) {
        Order order = orders[orderNum];
        order.draftAmount = order.draftAmount + amount;
    }

    //设置订单不可更新
    function setOrderNonupdatable(bytes32 orderNum) internal {
        Order order = orders[orderNum];
        if(order.updatable == OrderUpdatable.YES){
            order.updatable = OrderUpdatable.NO;
        }
    }






    //########
    //收票申请
    function receiveDraftApply(bytes32 draftNum, bytes32 applicantAccountNum, bytes32 applicantName, bytes32 applicantBankNum)returns(bool, bytes32, bytes32) {
        if(!judgeAccountCorrect(applicantAccountNum, applicantName, applicantBankNum)) {
            return (false, "7", "name or bankNum error");
        }
        Draft draft = drafts[draftNum];
        if(draft.drawerId != applicantAccountNum) {
            return (false, "8", "applicant is not drawer");
        }
        if(draft.draftNum == 0x0) {
            return (false, "1", "draft is not exist");
        }
        if(draft.draftStatus == "020006") {//状态为承兑已签收
            draft.firstOwner = draft.drawerId;
            draft.secondOwner = draft.payeeId;
            draft.draftStatus = "030001";
            draft.lastStatus = "020006";
            addDraftRecord(draftNum, "P40", 0x0, "receive draft apply", applicantAccountNum, draft.payeeId);
            deleteArrayElement(unSignDrafts[draft.drawerId], draftNum);
            return(true, "0", "apply receive draft success");
        }else {
            return (false, "2", "draftStatus is not satisfied");
        }
    }



    //########
    //P42 收票回复
    function receiveDraftResp(bytes32 draftNum, ResponseTypes responseType,
        bytes32 replyerAccountNum, bytes32 replyerAccountName, bytes32 replyerBankNum) returns(bool, bytes32, bytes32) {

        if(!judgeAccountCorrect(replyerAccountNum, replyerAccountName, replyerBankNum)) {
            return (false, "7", "name or bankNum error");
        }
        Draft draft = drafts[draftNum];
        if(draft.draftNum == 0x0) {
            return (false, "1", "draft is not exist");
        }
        if(draft.draftStatus  == "030001") {
            if(draft.secondOwner == replyerAccountNum) { //回复人必须为收票人
                if(responseType == ResponseTypes.SU00) {
                    addDraftRecord(draftNum, "P42", "SU00", "receive draft apply", 0x0, replyerAccountNum);
                    draft.firstOwner = replyerAccountNum;
                    draft.secondOwner = replyerAccountNum;
                    draft.lastStatus = "030001";
                    draft.draftStatus = "030006";
                    return(true, "0", "receive success");

                }else if(responseType == ResponseTypes.SU01) {
                    draft.firstOwner = draft.drawerId;
                    draft.secondOwner = draft.drawerId;
                    draft.lastStatus = "030001";
                    draft.draftStatus = "020006";
                    addDraftRecord(draftNum, "P42", "SU01", "reject receive draft apply", 0x0, replyerAccountNum);
                    resetOrderDraftAmount(draft.orderNum, draft.amount);
                    return(false, "6", "resp reject");
                }
            }else {
                  return(false, "2", "have no permission");
            }

        }else {
              return(false, "4", "draftStatus is not satisfied");
        }

    }


    //P56 背书申请
    function endorseApply(bytes32 draftNum, bytes32 orderNum, bytes32 applicantNum, bytes32 applicantName, bytes32 applicantBankNum,
        bytes32 endorseeNum)returns(bool, bytes32, bytes32) {

        bool flag;
        bytes32 codeStatus;
        bytes32 msg;
        (flag, codeStatus, msg) = judgeApplicant(draftNum, applicantNum, applicantName, applicantBankNum);
        if(!flag) {
            return (flag, codeStatus, msg);
        }
        Draft draft = drafts[draftNum];
        if(draft.draftStatus == "030006" || draft.draftStatus == "060006" || draft.draftStatus == "040006") {
        if(draft.draftStatus == "040001") {
            return (false, "3", "draft has been endorse");
        }
        draft.lastStatus = draft.draftStatus;
        draft.draftStatus = "040001";
        draft.secondOwner = endorseeNum;
        addDraftRecord(draftNum, "P56", 0x0, "endorse apply", applicantNum, endorseeNum);
        return (true, "0", "endorse success");
        }else {
            return (false, "4", "draft status is not satisfied");
        }
    }

    //P57 背书回复
    function endorseResp(bytes32 draftNum, ResultTypes result, bytes32 replyerNum, bytes32 replyerName,bytes32 replyerBankNum,
    bytes32 resultCode, bytes32 resultReason)returns (bool, bytes32, bytes32) {
        if(!judgeAccountCorrect(replyerNum, replyerName, replyerBankNum)) {
            return (false, "7", "name or bankNum error");
        }
        Draft draft = drafts[draftNum];
        if(draft.draftNum == 0x0) {
            return (false, "1", "draft is not exist");
        }
        if(draft.draftStatus!="040001"){
            return (false, "4", "draft status is not satisfied");
        }
        if(draft.secondOwner != replyerNum) {
            return (false, "3", "you can't operate this draft");
        }
        if(result == ResultTypes.SUCC) {
            addDraftRecord(draftNum, "P57", "SU00", "endorse resp", 0x0, replyerNum);
            draft.firstOwner = draft.secondOwner;
            draft.lastStatus = draft.draftStatus;
            draft.draftStatus = "040006";
            return (true, "0", "resp success");
        }else {
            draft.draftStatus = draft.lastStatus;
            draft.secondOwner = draft.firstOwner;
            addDraftRecord(draftNum, "P57", "SU01", "endorse resp", 0x0, replyerNum);
            return (false, "6", "resp reject");
        }
    }




    //=====================================================================================================

    //此区域放置一些全局的工具函数


    //从一个bytes32数组中删除某个数据
    function deleteArrayElement(bytes32[] storage a, bytes32 data) internal {
        uint position;
        for(uint i = 0; i < a.length; i++) {
            if(a[i] == data) {
                position = i;
                break;
            }
            position++;
        }
        if(position != a.length) {
            a[position] = a[a.length-1];
            a.length = a.length-1;
        }
    }

    //检验出票人的部分信息
    function judgeDrawer(bytes32 drawerId) internal returns (bool) {
        Account drawer = accounts[drawerId];
        if(drawer.ID == 0x0 || drawer.accountType == AccountTypes.RC00) {
            return false;
        }
        return true;
    }

    //检验承兑人的信息
    function judgeAcceptor(bytes32 acceptorId, DraftTypes draftType) internal returns (bool) {
        Account acceptor = accounts[acceptorId];
        if(acceptor.ID != 0x0) {//是电商平台客户
            if(draftType == DraftTypes.AC01 && acceptor.accountType == AccountTypes.RC00) {
                return true;
            }else if(draftType == DraftTypes.AC02&&acceptor.accountType == AccountTypes.RC01) {
                return true;
            }else {
                return false;
            }
        }else {
            return false;
        }
    }

    //检验收票人的信息
    function judgePayee(bytes32 payeeId)internal returns (bool) {
        Account payee = accounts[payeeId];
            if(payee.ID == 0x0 || payee.accountType == AccountTypes.RC00) {
                return false;
        }
        return true;
    }

    //判断账户是否正确，与姓名卡号是否匹配
    function judgeAccountCorrect(bytes32 accountNum, bytes32 name, bytes32 businessBankNum) internal returns (bool) {
        Account account = accounts[accountNum];
        if(account.name == name && account.businessBankNum == businessBankNum) {
            return true;
        }else {
            return false;
        }
    }






    function addDraftRecord(bytes32 draftNum, bytes32 busiType, bytes32 responseType, bytes32 mark,
        bytes32 applicantNum, bytes32 replyerNum) internal {

        uint len = allDraftRecords[draftNum].length;
        allDraftRecords[draftNum].length ++;
        allDraftRecords[draftNum][len].draftNum = draftNum;
        allDraftRecords[draftNum][len].busiType = busiType;
        allDraftRecords[draftNum][len].responseType = responseType;
        allDraftRecords[draftNum][len].mark = mark;
        allDraftRecords[draftNum][len].applicantNum = applicantNum;
        allDraftRecords[draftNum][len].replyerNum = replyerNum;

        if(replyerNum != 0x0) {//为回复操作时
            if(responseType == "SU00") { //回复同意之后持票人更改
                if(!(busiType == "P52" || busiType == "P54")) { //除承兑回复的其他回复请求，需要更改票据持有人
                    Draft draft = drafts[draftNum];
                    if(busiType!="P38"){
                         holdDrafts[replyerNum].push(draftNum);
                         deleteArrayElement(holdDrafts[draft.firstOwner], draftNum);
                    }else{
                         holdDrafts[applicantNum].push(draftNum);
                    }

                }
            }
            if(applicantNum==0x0){
                deleteArrayElement(unSignDrafts[replyerNum], draftNum);
            }
        }
        if(applicantNum != 0x0 && replyerNum != 0x0){//为请求操作时
            unSignDrafts[replyerNum].push(draftNum);
        }

    }




    function judgeApplicant(bytes32 draftNum, bytes32 applicantNum, bytes32 name, bytes32 businessBankNum) internal returns(bool, bytes32, bytes32) {
        if(judgeAccountCorrect(applicantNum, name, businessBankNum)) {
            Draft draft = drafts[draftNum];
                if(draft.draftNum == 0x0) {
                    return (false, "1", "draft is not exist");
                }
          if(draft.firstOwner != applicantNum) {
              return (false, "3", "you can't operate this draft");
          }
          return (true, "0", "success judge applicant");

        }else {
            return(false, "7", "name or bankNum error");
        }

    }


    //筛选出data数组中下标从startindex到endindex的数据进行返回
   function getSubArray(bytes32[] data,uint startindex,uint endindex) internal returns(bytes32[] result) {
        if (data.length ==0 ) {
            return (result);
        }

        if(startindex > endindex || data.length-1 < startindex ) {
            return (result);
        }
        uint endnumber = (endindex < (data.length-1)) ? endindex : (data.length-1) ;
        result = new bytes32[](endnumber - startindex + 1 );
        for(uint i=0; i < result.length; i++) {
            result[i] = data[startindex];
            startindex++;
        }
    }


    //========================================================================================================





































}