package bucket

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"io"
	"math/big"
	"strings"
)

type alg struct {
	hashFun func([]byte) string
	decoder func(string) ([]byte, error)
}

var availableIDgenAlgs = map[string]alg{
	"sha256base64": alg{GenerateUUIDfromTxSHAHash, base64.StdEncoding.DecodeString},
}

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateIntUUID returns a UUID based on RFC 4122 returning a big.Int
func GenerateIntUUID() *big.Int {
	uuid := GenerateBytesUUID()
	z := big.NewInt(0)
	return z.SetBytes(uuid)
}

// GenerateUUID returns a UUID based on RFC 4122
func GenerateUUID() string {
	uuid := GenerateBytesUUID()
	return uuidBytesToStr(uuid)
}



//GenerateHashFromSignature returns a hash of the combined parameters
func GenerateHashFromSignature(path string, ctor string, args []string) []byte {
	fargs := ctor
	if args != nil {
		for _, str := range args {
			fargs = fargs + str
		}
	}
	cbytes := []byte(path + fargs)

	b := make([]byte, len(cbytes))
	copy(b, cbytes)
	hash := ComputeCryptoHash(b)
	return hash
}

// GenerateUUIDfromTxSHAHash generates SHA256 hash using Tx payload, and uses its first
// 128 bits as a UUID
func GenerateUUIDfromTxSHAHash(txData []byte) string {
	txHash := sha256.Sum256(txData)
	return uuidBytesToStr(txHash[0:16])
}

// GenerateIDWithAlg generates an ID using a custom algorithm
func GenerateIDWithAlg(customIDgenAlg string, encodedPayload string) (string, error) {
	var alg = availableIDgenAlgs[customIDgenAlg]
	if alg.hashFun != nil && alg.decoder != nil {
		var payload, err = alg.decoder(encodedPayload)
		if err != nil {
			return "", err
		}
		return alg.hashFun(payload), nil
	}
	return "", fmt.Errorf("Wrong UUID generation algorithm was given.")
}

func uuidBytesToStr(uuid []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:])
}

// FindMissingElements identifies the elements of the first slice that are not present in the second
// The second slice is expected to be a subset of the first slice
func FindMissingElements(all []string, some []string) (delta []string) {
	all:
	for _, v1 := range all {
		for _, v2 := range some {
			if strings.Compare(v1, v2) == 0 {
				continue all
			}
		}
		delta = append(delta, v1)
	}
	return
}


// Append the [][]byte with separator,it will be more efficient in high concurrency
func JoinBytes(data [][]byte, separator string) []byte {
	// count the length of separator
	if(data == nil || len(data)==0){
		return nil
	}
	n := len(separator) * (len(data) - 1)
	for i := 0; i < len(data); i++ {
		n = n + len(data[i])
	}
	// allocate the memory of data
	mem := make([]byte, n)

	// copy data
	dp := copy(mem, data[0])
	for _, bytesData := range data[1:] {
		dp += copy(mem[dp:], separator)
		dp += copy(mem[dp:], bytesData)
	}
	return mem
}

// Append the []string with separator,it will be more efficient in high concurrency
func JoinString(data []string, separator string) string {
	// count the length of separator
	if(data == nil || len(data)==0){
		return ""
	}
	n := len(separator) * (len(data) - 1)
	for i := 0; i < len(data); i++ {
		n = n + len(data[i])
	}
	// allocate the memory of data
	mem := make([]byte, n)

	// copy data
	dp := copy(mem, data[0])
	for _, s := range data[1:] {
		dp += copy(mem[dp:], separator)
		dp += copy(mem[dp:], s)
	}
	return string(mem)
}

