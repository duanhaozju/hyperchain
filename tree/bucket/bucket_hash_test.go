package bucket

import (
	"testing"
)

func TestBucketHashCalculator(t *testing.T) {
	//initConfig(nil)
	//c := newBucketHashCalculator(newBucketKey(1, 1))
	//
	//testutil.AssertEquals(t, c.computeCryptoHash(), nil)
	//
	//c.addNextNode(newDataNode(newDataKey("chaincodeID1", "key1"), []byte("value1")))
	//
	//c.addNextNode(newDataNode(newDataKey("chaincodeID_2", "key_1"), []byte("value_1")))
	//c.addNextNode(newDataNode(newDataKey("chaincodeID_2", "key_2"), []byte("value_2")))
	//
	//c.addNextNode(newDataNode(newDataKey("chaincodeID3", "key1"), []byte("value1")))
	//c.addNextNode(newDataNode(newDataKey("chaincodeID3", "key2"), []byte("value2")))
	//c.addNextNode(newDataNode(newDataKey("chaincodeID3", "key3"), []byte("value3")))
	//
	//hash := c.computeCryptoHash()
	//expectedHashContent := expectedBucketHashContentForTest(
	//	[]string{"chaincodeID1", "key1", "value1"},
	//	[]string{"chaincodeID_2", "key_1", "value_1", "key_2", "value_2"},
	//	[]string{"chaincodeID3", "key1", "value1", "key2", "value2", "key3", "value3"},
	//)
	//t.Logf("Actual HashContent = %#v\n Expected HashContent = %#v", c.hashingData, expectedHashContent)
	//testutil.AssertEquals(t, hash, testutil.ComputeCryptoHash(expectedHashContent))
}
