package hts

import (
	"crypto"
	"github.com/pkg/errors"
	"hyperchain/p2p/hts/secimpl"
	"sync"
)

type ClientHTS struct {
	priKey_s   crypto.PrivateKey
	priKey     []byte
	pubKey_s   crypto.PublicKey
	pubKey     []byte
	sessionKey *SessionKey
	security   secimpl.Security
	CG         *CertGroup
	rwlock     *sync.RWMutex
}

// NewClientHTS creates and returns a new ClientHTS instance.
func NewClientHTS(sec secimpl.Security, cg *CertGroup) (*ClientHTS, error) {
	chts := &ClientHTS{
		security: sec,
		CG:       cg,
		rwlock:   new(sync.RWMutex),
	}
	chts.priKey = cg.eCERTPriv
	chts.priKey_s = cg.eCERTPriv_S
	return chts, nil
}

// VerifySign verifies whether the signature is generated by this cert.
// This method will not check if the cert is valid, but verify signature
// is valid.
func (ch *ClientHTS) VerifySign(sign, data, rawcert []byte) (bool, error) {
	return ch.security.VerifySign(sign, data, rawcert)
}

// GenShareKey generates a shared session key.
func (ch *ClientHTS) GenShareKey(rand, rawcert []byte) error {
	sk, err := ch.security.GenerateShareKey(ch.priKey, rand, rawcert)
	if err != nil {
		return err
	}
	ch.rwlock.Lock()
	ch.sessionKey = NewSessionKey(sk)
	ch.rwlock.Unlock()
	return nil
}

// Encrypt will use the shared session key to encrypt message.
func (ch *ClientHTS) Encrypt(msg []byte) ([]byte, error) {
	ch.rwlock.RLock()
	defer ch.rwlock.RUnlock()
	if ch.sessionKey == nil {
		return nil, errors.New("cannot get session Key,enc failed (nil).")
	}
	sKey := ch.sessionKey.GetKey()
	if sKey == nil {
		return nil, errors.New("cannot get session Key,enc failed.")
	}
	b, e := ch.security.Encrypt(sKey, msg)
	if e != nil {
		ch.sessionKey.SetOff()
	}
	return b, e
}

// Decrypt will use the shared session key to decrypt message.
func (ch *ClientHTS) Decrypt(msg []byte) ([]byte, error) {
	ch.rwlock.RLock()
	defer ch.rwlock.RUnlock()
	if ch.sessionKey == nil {
		return nil, errors.New("cannot get session Key,dec failed (nil).")
	}
	sKey := ch.sessionKey.GetKey()
	if sKey == nil {
		return nil, errors.New("cannot get session Key,enc failed.")
	}
	b, e := ch.security.Decrypt(sKey, msg)
	if e != nil {
		ch.sessionKey.SetOff()
	}
	return b, e
}

// GetSK returns the shared session key.
func (ch *ClientHTS) GetSK() []byte {
	ch.rwlock.RLock()
	defer ch.rwlock.RUnlock()
	return ch.sessionKey.GetKey()
}
